import React, { useState, useEffect } from 'react';
import { Edit2, Image as ImageIcon, Send, CheckCircle2, Loader2, Pencil } from 'lucide-react';
import { Card, CardContent, CardHeader, CardTitle } from '@/app/components/ui/card';
import { Button } from '@/app/components/ui/button';
import { Label } from '@/app/components/ui/label';
import { Badge } from '@/app/components/ui/badge';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/app/components/ui/select';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '@/app/components/ui/dialog';
import { Textarea } from '@/app/components/ui/textarea';
import { ImageUploader } from './content-audit/image-uploader';
import { GeneratedGallery, generateMockImages, GenerationStatus, GeneratedImage } from './content-audit/generated-gallery';
import { SocialPreviewTabs } from './content-audit/social-preview-tabs';
import { cn } from '@/app/components/ui/utils';
import { BobaProgress } from '@/app/components/ui/BobaProgress';
import { useBobaFakeProgress } from '@/app/hooks/useBobaFakeProgress';
import { TeaFlowProgressBar } from '@/app/components/ui/TeaFlowProgressBar';
import { useTeaFlowFakeProgress } from '@/app/hooks/useTeaFlowFakeProgress';

type Stage = 'waiting_input' | 'copy_generating' | 'copy_ready' | 'image_generating' | 'done';

interface CopyStyle {
  id: string;
  name: string;
  icon: string;
  content: string; // AI ç”¢å‡ºçš„åŸå§‹æ–‡æ¡ˆ
  editedText?: string; // ä½¿ç”¨è€…ç·¨è¼¯å¾Œçš„æ–‡æ¡ˆï¼ˆå¯é¸ï¼‰
}

interface ImageMeta {
  width: number;
  height: number;
  size: number;
}

export function ContentAuditCenter() {
  // Mock products data
  const products = [
    'çƒ¤æ¥Šå¥¶èŒ¶é®®èƒç´…',
    'é’è›™æ±',
  ];

  // Stage state machine
  const [stage, setStage] = useState<Stage>('waiting_input');
  
  // Form state
  const [selectedProduct, setSelectedProduct] = useState<string>('');
  
  // Image state
  const [uploadedImage, setUploadedImage] = useState<string | null>(null);
  const [uploadedMeta, setUploadedMeta] = useState<ImageMeta | null>(null);
  
  // Copy candidates state (initially empty, generated by AI)
  const [copyCandidates, setCopyCandidates] = useState<CopyStyle[]>([]);
  const [selectedCopyId, setSelectedCopyId] = useState<string | null>(null);
  
  // Image generation state
  const [generatedImages, setGeneratedImages] = useState<GeneratedImage[]>([]);
  const [selectedImage, setSelectedImage] = useState<string | null>(null);
  const [generationStatus, setGenerationStatus] = useState<GenerationStatus>('idle');
  const [generationProgress, setGenerationProgress] = useState(0);
  
  // Error message state
  const [errorMessage, setErrorMessage] = useState<string | null>(null);

  // Edit dialog state
  const [isEditDialogOpen, setIsEditDialogOpen] = useState(false);
  const [editingCopyId, setEditingCopyId] = useState<string | null>(null);
  const [editTextValue, setEditTextValue] = useState<string>('');

  // Boba progress state (for copy generation)
  const { progress, status, start, finish, reset } = useBobaFakeProgress({ expectedMs: 60000 });
  const [showBobaProgress, setShowBobaProgress] = useState(false);

  // TeaFlow progress state (for image generation)
  const { 
    progress: teaFlowProgress, 
    status: teaFlowStatus, 
    start: teaFlowStart, 
    finish: teaFlowFinish, 
    reset: teaFlowReset 
  } = useTeaFlowFakeProgress({ expectedMs: 60000 });
  const [showTeaFlowProgress, setShowTeaFlowProgress] = useState(false);
  const [selectedStyleName, setSelectedStyleName] = useState<string>('');

  // Reset function: clear copyCandidates, selectedCopyId, imageResult and return to waiting_input
  const resetState = () => {
    setCopyCandidates([]);
    setSelectedCopyId(null);
    setGeneratedImages([]);
    setSelectedImage(null);
    setGenerationStatus('idle');
    setGenerationProgress(0);
    setStage('waiting_input');
    setErrorMessage(null);
    setIsEditDialogOpen(false);
    setEditingCopyId(null);
    setEditTextValue('');
    reset();
    setShowBobaProgress(false);
    teaFlowReset();
    setShowTeaFlowProgress(false);
    setSelectedStyleName('');
  };

  // Handle image upload
  const handleImageUpload = (file: File, preview: string, meta: ImageMeta) => {
    setUploadedImage(preview);
    setUploadedMeta(meta);
    resetState();
  };

  // Handle image clear
  const handleImageClear = () => {
    setUploadedImage(null);
    setUploadedMeta(null);
    resetState();
  };

  // Handle product change
  const handleProductChange = (value: string) => {
    setSelectedProduct(value);
    resetState();
  };

  // Mock generateCopies API call
  const generateCopies = async (productName: string): Promise<CopyStyle[]> => {
    // Simulate API call delay
    await new Promise(resolve => setTimeout(resolve, 1500));
    
    // Use default templateId if backend requires it
    // In production API call, you can include: templateId: "product-only" (or other default)
    
    // Mock generated copies based on product
    return [
      {
        id: 'trendy',
        name: 'æ½®æµé¢¨æ ¼',
        icon: 'ğŸ”¥',
        content: `${productName} çµ•å°æ˜¯ä»Šå¹´å†¬å¤©æœ€chillçš„é¸æ“‡ï½æ¿ƒéƒçƒ¤ç³–é‡ä¸Šé…¸ç”œè‰è“ï¼Œæ¯ä¸€å£éƒ½æ˜¯é©šå–œğŸ’• é™æ™‚é–‹è³£ä¸­ï¼Œtagä½ çš„å§Šå¦¹ä¸€èµ·ä¾†æ‰“å¡ï¼`
      },
      {
        id: 'literary',
        name: 'æ–‡é’é¢¨æ ¼',
        icon: 'ğŸ“–',
        content: `å†¬æ—¥åˆå¾Œï¼Œä¸€æ¯${productName}ã€‚\n\næº«æš–çš„çƒ¤ç³–é¦™æ°£ï¼ŒåŒ…è£¹è‘—è“æœçš„æ¸…æ–°ï¼Œå¦‚åŒèˆŠæ™‚å…‰è£¡é‚£äº›ç¾å¥½çš„ç‰‡æ®µã€‚\n\nå­£ç¯€é™å®šï¼Œèˆ‡ä½ åˆ†äº«é€™ä»½å†¬å­£çš„å°ç¢ºå¹¸ã€‚`
      },
      {
        id: 'humor',
        name: 'å¹½é»˜é¢¨æ ¼',
        icon: 'ğŸ˜„',
        content: `è€é—†èªªï¼šã€Œé€™æ¯${productName}è³£ä¸å¥½å°±æ‰£ä½ è–ªæ°´ï¼ã€\næˆ‘èªªï¼šã€Œé‚£æˆ‘å…ˆå–ä¸‰æ¯å£“å£“é©šã€‚ã€\n\nçµæœ...æˆ‘çœŸçš„é€£å–ä¸‰æ¯ ğŸ¤£\n#å¤ªå¥½å–äº†å§ #æ¸›è‚¥æ˜å¤©å†èªª`
      }
    ];
  };

  // Handle AI copy generation button click (only generates copies, not images)
  const handleGenerateCopiesClick = async () => {
    // Check prerequisites: uploaded image + selected product
    if (!uploadedImage) {
      setErrorMessage('è«‹å…ˆä¸Šå‚³ç”¢å“åœ–ç‰‡');
      setTimeout(() => setErrorMessage(null), 3000);
      return;
    }
    
    if (!selectedProduct) {
      setErrorMessage('è«‹å…ˆé¸æ“‡ç”¢å“åç¨±');
      setTimeout(() => setErrorMessage(null), 3000);
      return;
    }
    
    // Start copy generation
    setStage('copy_generating');
    setCopyCandidates([]);
    setSelectedCopyId(null);
    setErrorMessage(null);
    
    // Show and start boba progress
    setShowBobaProgress(true);
    start();
    
    // ============================================
    // ğŸ”„ DEMO: æ¨¡æ“¬ API å®Œæˆï¼ˆ6 ç§’å¾Œè‡ªå‹•å®Œæˆï¼‰
    // ä¹‹å¾Œæ¥ API æ™‚ï¼Œè«‹å°‡ä»¥ä¸‹ setTimeout å€å¡Šæ›¿æ›ç‚ºï¼š
    //   try {
    //     const copies = await generateCopies(selectedProduct);
    //     finish(); // API æˆåŠŸå¾Œå‘¼å« finish()
    //     setCopyCandidates(copies);
    //     setStage('copy_ready');
    //     setTimeout(() => setShowBobaProgress(false), 1000); // é¡¯ç¤ºå®Œæˆå‹•ç•« 1 ç§’å¾Œæ”¶èµ·
    //   } catch (error) {
    //     reset(); // API å¤±æ•—æ™‚é‡ç½®
    //     setShowBobaProgress(false);
    //     setErrorMessage('æ–‡æ¡ˆç”Ÿæˆå¤±æ•—ï¼Œè«‹é‡è©¦');
    //     setStage('waiting_input');
    //     setTimeout(() => setErrorMessage(null), 3000);
    //   }
    // ============================================
    setTimeout(() => {
      finish(); // è§¸ç™¼å®Œæˆå‹•ç•«
      setTimeout(() => {
        // é¡¯ç¤ºå®Œæˆå‹•ç•« 1 ç§’å¾Œæ”¶èµ·
        setShowBobaProgress(false);
        // æ¨¡æ“¬ API å›å‚³çµæœ
        generateCopies(selectedProduct)
          .then((copies) => {
            setCopyCandidates(copies);
            setStage('copy_ready');
          })
          .catch((error) => {
            setErrorMessage('æ–‡æ¡ˆç”Ÿæˆå¤±æ•—ï¼Œè«‹é‡è©¦');
            setStage('waiting_input');
            setTimeout(() => setErrorMessage(null), 3000);
          });
      }, 1000);
    }, 6000);
  };

  // Handle image generation (called when user selects a copy style)
  const handleGenerateImage = async (copyId?: string) => {
    if (!uploadedImage) {
      setErrorMessage('è«‹å…ˆä¸Šå‚³ç”¢å“åœ–ç‰‡');
      setTimeout(() => setErrorMessage(null), 3000);
      return;
    }
    
    const copyIdToUse = copyId || selectedCopyId;
    if (!copyIdToUse) {
      setErrorMessage('è«‹å…ˆé¸æ“‡æ–‡æ¡ˆé¢¨æ ¼');
      setTimeout(() => setErrorMessage(null), 3000);
      return;
    }

    // Get the latest copy text (editedText ?? content)
    const copy = copyCandidates.find(c => c.id === copyIdToUse);
    if (!copy) {
      setErrorMessage('æ‰¾ä¸åˆ°é¸å–çš„æ–‡æ¡ˆ');
      setTimeout(() => setErrorMessage(null), 3000);
      return;
    }
    
    const latestCopyText = copy.editedText ?? copy.content;
    
    // Note: In real API call, this latestCopyText should be included in the payload
    // For example: await generateImagesAPI({ image: uploadedImage, copyText: latestCopyText, template })

    setStage('image_generating');
    setGenerationStatus('queued');
    setGeneratedImages([]);
    setSelectedImage(null);

    // Simulate async generation with progress
    setTimeout(() => {
      setGenerationStatus('generating');
      setGenerationProgress(0);
      
      const progressInterval = setInterval(() => {
        setGenerationProgress(prev => {
          if (prev >= 90) {
            clearInterval(progressInterval);
            return 90;
          }
          return prev + 10;
        });
      }, 200);

      // Generate mock images using Canvas
      // In production, this would be: generateImagesAPI({ image: uploadedImage, copyText: latestCopyText })
      generateMockImages(uploadedImage)
        .then((images) => {
          clearInterval(progressInterval);
          setGenerationProgress(100);
          setGeneratedImages(images);
          setGenerationStatus('done');
          setStage('done');
          // Auto-select the first generated image
          if (images.length > 0) {
            setSelectedImage(images[0].id);
          }
        })
        .catch((error) => {
          clearInterval(progressInterval);
          setGenerationStatus('idle');
          setGenerationProgress(0);
          setStage('copy_ready');
          setErrorMessage(`åœ–ç‰‡ç”Ÿæˆå¤±æ•—: ${error instanceof Error ? error.message : 'æœªçŸ¥éŒ¯èª¤'}`);
          setTimeout(() => setErrorMessage(null), 3000);
        });
    }, 500);
  };

  const handleSelectImage = (imageId: string) => {
    setSelectedImage(imageId);
  };

  const handleRegenerate = () => {
    if (selectedCopyId) {
      handleGenerateImage();
    }
  };

  // Handle edit copy button click
  const handleEditCopy = (e: React.MouseEvent, copyId: string) => {
    e.stopPropagation(); // Prevent card selection when clicking edit
    const copy = copyCandidates.find(c => c.id === copyId);
    if (copy) {
      // Use editedText if exists, otherwise use original content
      const currentText = copy.editedText ?? copy.content;
      setEditingCopyId(copyId);
      setEditTextValue(currentText);
      setIsEditDialogOpen(true);
    }
  };

  // Handle save edited copy
  const handleSaveEdit = () => {
    if (!editingCopyId) return;
    
    const trimmedValue = editTextValue.trim();
    if (!trimmedValue) {
      // Don't allow saving empty text
      return;
    }

    // Update the copy candidate with edited text
    setCopyCandidates(prev => prev.map(copy => 
      copy.id === editingCopyId 
        ? { ...copy, editedText: trimmedValue }
        : copy
    ));

    // Close dialog and reset edit state
    setIsEditDialogOpen(false);
    setEditingCopyId(null);
    setEditTextValue('');
  };

  // Handle cancel edit
  const handleCancelEdit = () => {
    setIsEditDialogOpen(false);
    setEditingCopyId(null);
    setEditTextValue('');
  };

  // Handle copy style selection - triggers image generation with TeaFlow progress
  const handleSelectCopyStyle = (copyId: string) => {
    setSelectedCopyId(copyId);
    setErrorMessage(null);
    
    // è·å–é£æ ¼åç§°ç”¨äºæ˜¾ç¤º
    const copy = copyCandidates.find(c => c.id === copyId);
    const styleName = copy?.name || 'æ­¤é¢¨æ ¼';
    setSelectedStyleName(styleName);
    
    // æ¸…ç©ºä¹‹å‰çš„ç”Ÿæˆç»“æœ
    setGeneratedImages([]);
    setSelectedImage(null);
    
    // æ˜¾ç¤ºå¹¶å¯åŠ¨ TeaFlow è¿›åº¦æ¡
    setShowTeaFlowProgress(true);
    teaFlowStart();
    
    // è®¾ç½®çŠ¶æ€ä¸ºå›¾ç‰‡ç”Ÿæˆä¸­
    setStage('image_generating');
    setGenerationStatus('generating');
    setGenerationProgress(0);
    
    // ============================================
    // ğŸ”„ DEMO: æ¨¡æ“¬ API å®Œæˆï¼ˆ6 ç§’å¾Œè‡ªå‹•å®Œæˆï¼‰
    // ä¹‹å¾Œæ¥ API æ™‚ï¼Œè«‹å°‡ä»¥ä¸‹ setTimeout å€å¡Šæ›¿æ›ç‚ºï¼š
    //   try {
    //     const images = await generateImagesAPI({ 
    //       image: uploadedImage, 
    //       copyText: copy.editedText ?? copy.content
    //     });
    //     teaFlowFinish(); // API æˆåŠŸå¾Œå‘¼å« finish()
    //     setGeneratedImages(images);
    //     setGenerationStatus('done');
    //     setStage('done');
    //     if (images.length > 0) {
    //       setSelectedImage(images[0].id);
    //     }
    //     setTimeout(() => setShowTeaFlowProgress(false), 1200); // é¡¯ç¤ºå®Œæˆå‹•ç•« 1.2 ç§’å¾Œæ”¶èµ·
    //   } catch (error) {
    //     teaFlowReset(); // API å¤±æ•—æ™‚é‡ç½®
    //     setShowTeaFlowProgress(false);
    //     setErrorMessage('åœ–ç‰‡ç”Ÿæˆå¤±æ•—ï¼Œè«‹é‡è©¦');
    //     setStage('copy_ready');
    //     setTimeout(() => setErrorMessage(null), 3000);
    //   }
    // ============================================
    setTimeout(() => {
      teaFlowFinish(); // è§¸ç™¼å®Œæˆå‹•ç•«
      setTimeout(() => {
        // é¡¯ç¤ºå®Œæˆå‹•ç•« 1.2 ç§’å¾Œæ”¶èµ·é€²åº¦æ¢ä¸¦é¡¯ç¤ºçµæœ
        setShowTeaFlowProgress(false);
        // æ¨¡æ“¬ API å›å‚³çµæœï¼ˆä½¿ç”¨ç¾æœ‰çš„ generateMockImagesï¼‰
        if (uploadedImage) {
          generateMockImages(uploadedImage)
            .then((images) => {
              setGeneratedImages(images);
              setGenerationStatus('done');
              setStage('done');
              if (images.length > 0) {
                setSelectedImage(images[0].id);
              }
            })
            .catch((error) => {
              setGenerationStatus('idle');
              setStage('copy_ready');
              setErrorMessage('åœ–ç‰‡ç”Ÿæˆå¤±æ•—ï¼Œè«‹é‡è©¦');
              setTimeout(() => setErrorMessage(null), 3000);
            });
        }
      }, 1200);
    }, 6000);
  };

  // Get selected copy text (use editedText if exists, otherwise use original content)
  const selectedCopyText = selectedCopyId 
    ? (() => {
        const copy = copyCandidates.find(c => c.id === selectedCopyId);
        return copy ? (copy.editedText ?? copy.content) : '';
      })()
    : '';

  // Get selected generated image URL (only from generatedImages, never fallback to uploadedImage)
  // If no image is selected but we have generated images, use the first one
  const selectedGeneratedImageUrl = selectedImage 
    ? generatedImages.find(img => img.id === selectedImage)?.url || null
    : generatedImages.length > 0 
      ? generatedImages[0].url 
      : null;

  return (
    <div className="h-full flex" style={{ backgroundColor: 'var(--df-bg)' }}>
      {/* å·¦å´ï¼šç”¢å“è³‡è¨Šèˆ‡æ–‡æ¡ˆç”Ÿæˆ */}
      <div className="flex-1 p-6 overflow-y-auto">
        <div className="space-y-6 pr-4 max-w-4xl">
          <div>
            <h2 className="text-2xl font-semibold mb-1">å…§å®¹å¯©æ ¸ä¸­å¿ƒ</h2>
            <p className="text-sm text-muted-foreground">AI å¤šé¢¨æ ¼ç”¢å‡º Â· äººå·¥æœ€å¾Œå¯©æ ¸</p>
          </div>
          
          {/* ç”¢å“è³‡è¨Šè¼¸å…¥å€ */}
          <Card>
            <CardHeader>
              <CardTitle className="text-base">ç”¢å“è³‡è¨Šè¼¸å…¥</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="grid md:grid-cols-2 gap-6">
                {/* å·¦æ¬„ï¼šè¡¨å–®æ¬„ä½å †ç–Š */}
                <div className="space-y-4">
                  <div className="space-y-2">
                    <Label>ç”¢å“åç¨±</Label>
                    <Select
                      value={selectedProduct}
                      onValueChange={handleProductChange}
                      disabled={stage === 'copy_generating' || stage === 'image_generating'}
                    >
                      <SelectTrigger>
                        <SelectValue placeholder="è«‹é¸æ“‡ç”¢å“" />
                      </SelectTrigger>
                      <SelectContent>
                        {products.map((product) => (
                          <SelectItem key={product} value={product}>
                            {product}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>
                  
                  {/* Action Panel */}
                  <div className="pt-4">
                    <div className="space-y-3">
                      <div className="text-sm font-medium">è¡ŒéŠ·</div>
                      <Button
                        onClick={handleGenerateCopiesClick}
                        disabled={
                          !uploadedImage || 
                          !selectedProduct ||
                          stage === 'copy_generating' || 
                          stage === 'image_generating'
                        }
                        className="w-full"
                        style={{ backgroundColor: 'var(--df-header)', color: 'white' }}
                      >
                        {stage === 'copy_generating' ? (
                          <>
                            <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                            ç”Ÿæˆä¸­â€¦
                          </>
                        ) : (
                          <>
                            <ImageIcon className="w-4 h-4 mr-2" />
                            æ–‡æ¡ˆç”¢ç”Ÿ
                          </>
                        )}
                      </Button>
                      
                      {/* Boba Progress - é¡¯ç¤ºåœ¨æŒ‰éˆ•ä¸‹æ–¹ */}
                      {showBobaProgress && (
                        <div className="mt-3">
                          <BobaProgress
                            progress={progress}
                            status={status}
                            showCounter={true}
                            size="md"
                          />
                        </div>
                      )}
                    </div>
                  </div>
                </div>
                
                {/* å³æ¬„ï¼šç”¢å“ç…§ç‰‡ä¸Šå‚³ */}
                <div className="space-y-2">
                  <ImageUploader 
                    value={uploadedImage}
                    onImageUpload={handleImageUpload}
                    onClear={handleImageClear}
                  />
                </div>
              </div>
            </CardContent>
          </Card>
          
          {/* AI å¤šé¢¨æ ¼ç”¢å‡ºå€ */}
          <div>
            <h3 className="font-semibold mb-4">AI å¤šé¢¨æ ¼æ–‡æ¡ˆå°æ¯”</h3>
            
            {errorMessage && (
              <div className="mb-3 p-2 text-sm text-destructive bg-destructive/10 border border-destructive/20 rounded">
                {errorMessage}
              </div>
            )}
            
            {stage === 'copy_generating' && (
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                {[1, 2, 3].map((i) => (
                  <Card key={i} className="h-full">
                    <CardContent className="p-4">
                      <div className="space-y-3">
                        <div className="flex items-center justify-between">
                          <div className="h-4 w-20 bg-gray-200 rounded animate-pulse" />
                          <div className="h-4 w-4 bg-gray-200 rounded animate-pulse" />
                        </div>
                        <div className="space-y-2">
                          <div className="h-3 w-full bg-gray-200 rounded animate-pulse" />
                          <div className="h-3 w-full bg-gray-200 rounded animate-pulse" />
                          <div className="h-3 w-3/4 bg-gray-200 rounded animate-pulse" />
                        </div>
                        <div className="h-8 w-full bg-gray-200 rounded animate-pulse" />
                      </div>
                    </CardContent>
                  </Card>
                ))}
              </div>
            )}
            
            {stage === 'copy_ready' || stage === 'image_generating' || stage === 'done' ? (
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4 items-stretch">
                {copyCandidates.map((copy) => {
                  const isSelected = selectedCopyId === copy.id;
                  return (
                    <Card 
                      key={copy.id}
                      className={cn(
                        "relative transition-all h-full flex flex-col",
                        isSelected 
                          ? "ring-2 ring-primary border-primary" 
                          : "border-border hover:bg-muted/20 hover:shadow-md"
                      )}
                    >
                      <CardHeader className="pb-3">
                        <CardTitle className="text-sm flex items-center justify-between">
                          <span className="flex items-center gap-2">
                            <span className="text-lg">{copy.icon}</span>
                            {copy.name}
                          </span>
                          <Button 
                            variant="ghost" 
                            size="sm"
                            onClick={(e) => handleEditCopy(e, copy.id)}
                            className="h-6 w-6 p-0"
                            disabled={stage === 'image_generating'}
                          >
                            <Pencil className="w-3 h-3" />
                          </Button>
                        </CardTitle>
                      </CardHeader>
                      <CardContent className="flex-1 flex flex-col">
                        <p className="text-xs whitespace-pre-line leading-relaxed text-muted-foreground flex-1">
                          {copy.editedText ?? copy.content}
                        </p>
                      </CardContent>
                      {/* Footer with Select Button */}
                      <div className="p-4 pt-0 border-t border-border mt-auto space-y-2">
                        {copy.editedText && (
                          <div className="text-xs text-muted-foreground text-center">
                            å·²ç·¨è¼¯
                          </div>
                        )}
                        <Button
                          variant={isSelected ? "default" : "outline"}
                          size="sm"
                          className="w-full"
                          disabled={stage === 'image_generating'}
                          onClick={(e) => {
                            e.stopPropagation();
                            handleSelectCopyStyle(copy.id);
                          }}
                        >
                          {isSelected ? (
                            <>
                              <CheckCircle2 className="w-4 h-4 mr-2" />
                              å·²é¸æ“‡
                            </>
                          ) : (
                            'é¸æ“‡æ­¤é¢¨æ ¼'
                          )}
                        </Button>
                      </div>
                    </Card>
                  );
                })}
              </div>
            ) : stage === 'waiting_input' && (
              <div className="text-center py-8 text-sm text-muted-foreground">
                è«‹ä¸Šå‚³ç”¢å“åœ–ç‰‡ã€é¸æ“‡ç”¢å“åç¨±ï¼Œç„¶å¾Œé»æ“Šã€Œæ–‡æ¡ˆç”¢ç”Ÿã€ç”Ÿæˆæ–‡æ¡ˆ
              </div>
            )}
          </div>
        </div>
      </div>
      
      {/* å³å´ï¼šè¦–è¦ºé è¦½ */}
      <div 
        className="flex-1 p-6 space-y-6 overflow-y-auto border-l"
        style={{ backgroundColor: 'white' }}
      >
        <div>
          <h3 className="font-semibold mb-4">åœ–åƒé è¦½èˆ‡æ¨¡æ“¬</h3>
          
          {/* TeaFlow Progress Bar - é¡¯ç¤ºåœ¨å³ä¸Šç‹€æ…‹å€ */}
          {showTeaFlowProgress && (
            <div className="mb-4">
              <TeaFlowProgressBar
                progress={teaFlowProgress}
                status={teaFlowStatus}
                label={selectedStyleName ? `æ­£åœ¨å¥—ç”¨ã€Œ${selectedStyleName}ã€...` : 'æ­£åœ¨ç”Ÿæˆåœ–ç‰‡...'}
                showCounter={true}
                compact={true}
              />
            </div>
          )}
          
          {/* Generated Gallery - Show based on stage, never show original image */}
          <GeneratedGallery
            uploadedImage={null}
            generatedImages={generatedImages}
            selectedImage={selectedImage}
            generationStatus={generationStatus}
            generationProgress={generationProgress}
            onSelectImage={handleSelectImage}
            onRegenerate={handleRegenerate}
            stage={stage}
          />

          {/* Social Preview Tabs - Always show */}
          <div className="mt-6">
            <SocialPreviewTabs
              selectedGeneratedImage={selectedGeneratedImageUrl}
              selectedCopy={selectedCopyText}
              productName={selectedProduct}
              hasGeneratedImages={generatedImages.length > 0}
            />
          </div>
          
          {/* Action Buttons */}
          <div className="mt-6 space-y-2">
            <Button 
              className="w-full"
              style={{ backgroundColor: 'var(--df-accent)', color: 'white' }}
              disabled={!selectedImage || teaFlowStatus === 'running'}
            >
              <Send className="w-4 h-4 mr-2" />
              ç¢ºèªç™¼å¸ƒ
            </Button>
          </div>
          
          {/* Info Panel */}
          <div className="mt-4 p-3 bg-gray-50 rounded text-xs space-y-1">
            <div className="flex justify-between">
              <span className="text-muted-foreground">ç”¢å“:</span>
              <span className="font-medium">{selectedProduct || 'æœªé¸æ“‡'}</span>
            </div>
            <div className="flex justify-between">
              <span className="text-muted-foreground">ç‹€æ…‹:</span>
              <Badge variant="outline" className="text-yellow-600 border-yellow-600">å¾…å¯©æ ¸</Badge>
            </div>
            {uploadedMeta && (
              <div className="flex justify-between">
                <span className="text-muted-foreground">åœ–ç‰‡å°ºå¯¸:</span>
                <span>{uploadedMeta.width}Ã—{uploadedMeta.height}</span>
              </div>
            )}
          </div>
        </div>
      </div>

      {/* Edit Copy Dialog */}
      <Dialog 
        open={isEditDialogOpen} 
        onOpenChange={(open) => {
          if (!open) {
            // When dialog closes (by any means), reset edit state
            handleCancelEdit();
          } else {
            setIsEditDialogOpen(true);
          }
        }}
      >
        <DialogContent className="sm:max-w-[600px]">
          <DialogHeader>
            <DialogTitle>ç·¨è¼¯æ–‡æ¡ˆ</DialogTitle>
          </DialogHeader>
          <div className="space-y-4 py-4">
            <div className="space-y-2">
              <Label htmlFor="edit-textarea">æ–‡æ¡ˆå…§å®¹</Label>
              <Textarea
                id="edit-textarea"
                value={editTextValue}
                onChange={(e) => setEditTextValue(e.target.value)}
                placeholder="è«‹è¼¸å…¥æ–‡æ¡ˆå…§å®¹"
                className="min-h-[200px]"
                rows={8}
              />
            </div>
          </div>
          <DialogFooter>
            <Button
              variant="outline"
              onClick={handleCancelEdit}
            >
              å–æ¶ˆ
            </Button>
            <Button
              onClick={handleSaveEdit}
              disabled={!editTextValue.trim()}
            >
              å„²å­˜
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}
